Progetto 2020

1) Realizzare un sistema di ANALISI SEMANTICA per il linguaggio SimplePlus in allegato.
In  particolare, il sistema deve controllare

* di variabili/funzioni non dichiarate
* di variabili dichiarate piu` volte nello stesso ambiente (in questa analisi e`
  corretto il codice int x = 4 ; delete x ; int x = 5 ;)
* parametri attuali non conformi ai parametri formali (inclusa la verifica sui 
  parametri passati per var)
* la correttezza dei tipi 

Inoltre deve controllare gli accessi a identificatori "cancellati" con particolare
attenzione all'aliasing implementando il sistema visto a lezione

2) Definire un linguaggio bytecode per eseguire programmi in SimplePlus, scrivere 
la compilazione e implementare l'interprete. In particolare:

A. Il bytecode deve avere istruzioni per una macchina a pila che memorizza in un 
   apposito registro il valore dell'ultima istruzione calcolata [vedi slide delle lezioni]
B. Implementare l'interprete per il bytecode.
C. Compilare ed eseguire i programmi del linguaggio ad alto livello.

CONSEGNA: Occorre consegnare il pacchetto completo di tutte le fasi della compilazione.
E` possibile anche modificare i file dell' assegnamento precedente, se necessario.
Allegare anche una breve descrizione/analisi delle scelte fatte e su come 
istallare/eseguire in Eclipse il vostro compilatore. In caso di problemi, chiamero`
in aiuto qualcuno di voi.

Il pacchetto dovra` essere chiamato Cognome1_Cognome2.zip (dove il Cognome1, Cognome2,
etc sono i cognomi dei componenti del gruppo). Potete consegnarlo QUANDO VOLETE caricandolo 
su google drive e inviandomi l'indirizzo. Tenete
conto che io ho bisogno di qualche giorno per correggerlo e fare l'orale.



CODICI DA VERIFICARE:
=====
 int x = 4 ; delete x ; int x = 5 ;   // questo codice e` corretto!
=====
f(var int x, var int y){ delete x; delete y; }
    //  cosa accade in {int x = 3 ; f(x,x) ;} // è sbagliato
=====
f(var int x, int y){if (y == 0) delete x; else x=x+y ; } // è giusto e ritorna d
=====
h(var int x, var int y){ if (y==0) delete x ; else { x = x-1; h(x,y); } } // è giusto (punto fisso) e ritorna d
=====
g(var int x, var int y){ if (y==0) delete x ; else { x = x-1; g(x,y) ; delete x ;} // è sbagliato
=====
int x = 1;
f(int y){ if (y == 0) then { print(x); } else { f(y-1); } // è sbagliato (x non esiste)
f(54);
=====
int u = 1 ;
f(var int x, int n){ 
	if (n == 0) then { print(x) ;}
	else { int y = x*n ; f(y,n-1) ; }	// è giusto
	delete x ;
}
f(u,6) ;
=====
f(int m, int n){
	if (m > n) { print(m + n) ;}
	else { int x = 1 ; f(m + 1, n + 1); }	// è corretto
}
f(5,4) ;
// cosa succede se la invoco con f(4,5)?
=====

------------------------------------------------------------------

L'analisi semantica *non e` scritta nella pietra*. Due analizzatori possono essere eccellenti pur riconoscendo programmi differenti. Uno degli obiettivi del progetto (e del corso) e` che voi comprendiate cosa significa Analisi Semantica e come si implementa. Nulla toglie che ognuno di voi, nella propria analisi semantica, riconosca/rifiuti programmi differenti. L'importante e` che voi comprendiate perché ciò accade (cioè per quale motivo avete fatto questa scelta). Datemi le motivazioni e vi assicuro che non sarete penalizzati.
Qui sotto trovate accettazioni/rifiuto di alcuni programmi da parte dell'analizzatore che io ho in mente (e che non ho implementato). Il mio analizzatore è guidato dalla semplicità: voglio regole di inferenza facili e implementazione facile. Voi potete discostarvi per_nulla/poco/molto da esso e io ne sarei felice se lo faceste come sarei anche contento di discutere con voi perché lo avete fatto.

* int x ; delete x; int x ;  // accettato perche` la variabile viene dichiarata, cancellata e ridichiarata.
* int x = 4; if (e) { delete x; } else {x = 1 ;} ; int x = 5; // dove "e" e` una espressione booleana. Qui nella continuazione del condizionale "x" risulta cancellata. Quindi il programma e` accettato. Si riesce a far di meglio? Non in maniera semplice, secondo me.
* int x; void f(int var y) { delete y; } ; f(x); int x; // accettato: a tutti gli effetti e` come il primo programma. Fare delete x o fare f(x) e` la stessa cosa.
* int x; void f(int var y) {  if (y == 0) { delete y; } } ; f(x); int x; // questo e` un misto del primo e secondo caso. Quindi, il mio "semplice"  analizzatore lo accetta. 
* int x; delete x; bool x;  // rifiutato perche` in questo linguaggio le variabili sono allocate sulla pila e il mio *semplice* compilatore alloca 4 byte per un intero, 1 per un booleano, etc. E qui ci sarebbero problemi durante la generazione di codice/esecuzione. Ovviamente si può complicare.




